// SPDX-License-Identifier: LicenseRef-DCL-1.0
// SPDX-FileCopyrightText: Copyright (c) 2020 Rain Open Source Software Ltd
pragma solidity =0.8.25;

import "forge-std/Test.sol";
import "src/lib/caller/LibContext.sol";
import "./LibContextSlow.sol";

contract LibContextTest is Test {
    function testBase() public view {
        bytes32[] memory baseContext = LibContext.base();

        assertEq(baseContext.length, 2);
        assertEq(baseContext[0], bytes32(uint256(uint160(msg.sender))));
        assertEq(baseContext[1], bytes32(uint256(uint160(address(this)))));
        assertTrue(msg.sender != address(this));
    }

    /// forge-config: default.fuzz.runs = 100
    function testBuildStructureReferenceImplementation(bytes32[][] memory base) public view {
        bytes32[] memory unsignedContext = new bytes32[](3);
        unsignedContext[0] = bytes32(uint256(1));
        unsignedContext[1] = bytes32(uint256(2));
        unsignedContext[2] = bytes32(uint256(3));

        // This was generated as a new wallet by cast.
        address signer = 0xc9A34471D83253B148C821886278ae22EbaB23E4;
        bytes32 signerPrivateKey = bytes32(0x61b952d0c26214380daf3ca0a8ec9316682d63673db12d723c30417c86dbfca2);

        bytes32 toSign = ECDSA.toEthSignedMessageHash(LibHashNoAlloc.hashWords(unsignedContext));

        SignedContextV1[] memory signedContexts = new SignedContextV1[](1);
        signedContexts[0] = SignedContextV1({
            signer: signer,
            context: unsignedContext,
            // Signature generated by cast.
            signature: hex"8e95799bf4f8967b8dfd02a57c4b0d5294149ad47bd8f657e63efb04e205160a176dc000ba8b240a4e8e5e6a31b3939d4ac0efdeb790f95d84dd1296b22abc561b"
        });

        bytes32[][] memory expected = LibContextSlow.buildStructureSlow(base, signedContexts);
        bytes32[][] memory actual = LibContext.build(base, signedContexts);
        assertEq(expected.length, actual.length);

        for (uint256 i = 0; i < expected.length; i++) {
            assertEq(expected[i], actual[i]);
        }
    }

    function testBuild0() public view {
        // @todo test this better.
        bytes32[][] memory expected = new bytes32[][](1);
        expected[0] = LibContext.base();
        bytes32[][] memory built = LibContext.build(new bytes32[][](0), new SignedContextV1[](0));
        assertEq(expected.length, built.length);

        for (uint256 i = 0; i < expected.length; i++) {
            assertEq(expected[i], built[i]);
        }
    }

    function testBuildGas0() public view {
        LibContext.build(new bytes32[][](0), new SignedContextV1[](0));
    }
}
